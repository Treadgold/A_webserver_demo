<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>

<!-- Prism Bash/Shell component -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>

<meta charset="UTF-8">
<title>From Maps to Servers</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
/* ---------------- RESET ---------------- */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: #1a202c;
    overflow: hidden;
}

/* ---------------- SLIDE CONTAINER ---------------- */
.slide-container {
    width: 100vw;
    height: 100vh;
}

/* ---------------- BASE SLIDE ---------------- */
.slide {
    display: none;
    width: 100%;
    height: 100%;
    background: #ffffff;
    padding: 40px 80px;
    flex-direction: column;
}

.slide.active {
    display: flex;
}

/* ---------------- HEADER ---------------- */
.slide-header {
    flex: 0 0 auto;
    text-align: center;
    margin-bottom: 30px;
}

.slide-header h1 {
    font-size: 3.2em;
    color: #1a202c;
}

.slide-header h2 {
    font-size: 2.0em;
    color: #2d3748;
    padding-top: 15px;
    border-bottom: 4px solid #4c51bf;
    display: inline-block;
    padding-bottom: 10px;
}

/* ---------------- BODY (VERTICAL CENTER) ---------------- */
.slide-body {
    flex: 1;
    display: flex;
    align-items: center;   /* vertical centering */
    justify-content: center;
}

/* ---------------- LAYOUTS ---------------- */
.layout-1,
.layout-2,
.layout-3 {
    width: 100%;
    max-width: 1200px;
}

.layout-1 {
    text-align: center;
}

.layout-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 60px;
    align-items: center;
}

.layout-3 {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 40px;
    align-items: center;
}

/* ---------------- COLUMN CONTENT ---------------- */
.column {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.column img {
    max-width: 100%;
    height: auto;
    border-radius: 12px;
}

/* ---------------- TEXT ---------------- */
p {
    font-size: 1.6em;
    color: #4a5568;
    line-height: 1.6;
    margin-bottom: 12px;
}

ul {
    list-style: none;
    font-size: 1.6em;
    color: #2d3748;
}

li {
    padding-left: 28px;
    position: relative;
    margin-bottom: 10px;
}

li::before {
    content: "▸";
    position: absolute;
    left: 0;
    color: #4c51bf;
}

/* ---------------- NAV ---------------- */
.navigation {
    position: fixed;
    bottom: 30px;
    right: 30px;
    display: flex;
    gap: 15px;
}

button {
    background: #4c51bf;
    color: white;
    border: none;
    padding: 14px 28px;
    font-size: 1.1em;
    border-radius: 8px;
    cursor: pointer;
}

button:disabled {
    background: #a0aec0;
}

.slide-number {
    position: fixed;
    bottom: 30px;
    left: 30px;
    background: #ffffff;
    padding: 10px 18px;
    border-radius: 8px;
    font-size: 1.1em;
}
</style>
</head>

<body>

<div class="slide-container">

<!-- SLIDE 1: ONE COLUMN -->
<div class="slide active">
    <div class="slide-header">
        <h1>Maps & Programming</h1>
        <h2>Step-by-step instructions: you can succeed, but you’re blind.</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
        <div class="column">
            <p>Imagine being handed a piece of paper with directions.</p>
            <p>Miss one step and you’re lost.</p>
            <p>No context. No recovery.</p>
        </div>
        <div class="column">
            <img src="hand_written.jpg" width = 600 alt="Hand drawn">
        </div>
        </div>
    </div>
</div>

<!-- SLIDE 2: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h1>Instructions vs Maps</h1>
        <h2>Interactive map: you see the system, and the landmarks make sense.</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <p>You can see every street, every landmark, every connection</p>
                <p>You gain context: you see why shortcuts exist, why bridges are built here, and where traffic bottlenecks are.</p>
                <p>Make a wrong turn? The system reroutes you and shows whys</p>
                <p>You understand not just how to get there—but why the path works this way</p>
            </div>

            <div class="column">
                <img src="google_map.jpg" width = 600 alt="maps">
            </div>
        </div>
    </div>
</div>

<!-- SLIDE 3: THREE COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>What This Talk Will Give You</h2>
    </div>

    <div class="slide-body">
        <div class="layout-3">
            <!-- Left column: What the talk is about -->
            <div class="column">
                <p><strong>What We’ll Explore</strong></p>
                <ul>
                    <li>How a simple server works under the hood</li>
                    <li>Why frameworks like Flask/FastAPI use decorators</li>
                    <li>What asyncio is really doing for concurrency</li>
                    <li>How abstractions solve problems step by step</li>
                    <li>Landmarks to navigate future frameworks with insight</li>
                </ul>
            </div>

            <!-- Center column: Visual candy -->
            <div class="column" style="text-align:center;">
                <img src="artistic_diagram.png" width="500" alt="Network complexity visualization">
            </div>

            <!-- Right column: What the talk is NOT about -->
            <div class="column">
                <p><strong>What We Won’t Cover</strong></p>
                <ul>
                    <li>Complete, production-ready FastAPI apps</li>
                    <li>Deep frontend HTML/CSS or JavaScript</li>
                    <li>Advanced database optimization</li>
                    <li>All edge cases or exhaustive error handling</li>
                    <li>Turning you into a framework developer in one hour</li>
                </ul>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 4: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>A Modern Web Stack is Big</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <p>- You need 8-10 different pieces minimum</p>
                <p>- Load balancing, reverse proxies, ASGI servers, databases, caching, message queues</p>
                <p>- SSL certificates, security headers, rate limiting, monitoring</p>
                <p>- This can take weeks to set up properly</p>
            </div>
            <div class="column">
                <img src="modern_stack.png" width=450>
            </div>
        </div>
    </div>
</div>

<!-- SLIDE 5: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>The Absurd Extreme: A Minimal Web Server</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: talking points -->
            <div class="column">
                <ul>
                    <li>Here's the opposite extreme – the world's simplest web server</li>
                    <li>Just 10 lines of Bash using netcat to listen on a port</li>
                    <li>No matter what you request – /, /about, /api/users – you get the same response</li>
                    <li>No file serving, no routing, no frameworks, no magic</li>
                    <li>But it WORKS! You could even point a domain at it and serve a page</li>
                </ul>
            </div>

            <!-- Right column: code block -->
            <div class="column">
                <pre><code class="language-bash">
#!/bin/bash

while true; do
  nc -l -p 8018 <<'EOF'
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 20
Connection: close

<h1>Hello World</h1>
EOF
done
</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 6: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>From the Absurd to Reality: Python Sockets</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: intro text -->
            <div class="column">
                <p>On the last slide, we saw the world’s simplest web server: one Bash script, one static response. Fun, but not real-world.</p>
                <p>Now, we’ll start building a server the Python way, from the bottom up:</p>
                <ul>
                    <li>Set up a socket to listen for connections</li>
                    <li>Accept a client connection and send raw data</li>
                    <li>No frameworks yet—just the raw mechanics of networking</li>
                    <li>We’ll gradually layer features until it becomes a modern, async web server</li>
                </ul>
                <p>Let’s jump into VS Code and see this in action, step by step.</p>
            </div>

            <!-- Right column: code block -->
            <div class="column">
                <pre><code class="language-python">import socket

def main() -> None:
    server_socket: socket.socket = socket.socket(
        socket.AF_INET,
        socket.SOCK_STREAM,
    )
    server_socket.bind(("127.0.0.1", 8002))
    server_socket.listen(1)

    print("Listening on http://127.0.0.1:8002")

    client_socket, addr = server_socket.accept()
    print(f"Connection from {addr}")

    # Send raw bytes — not valid HTTP
    client_socket.sendall(b"Hello from a socket!")
    client_socket.close()
    server_socket.close()


if __name__ == "__main__":
    main()
</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 7: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>The Core Server Loop</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: explanation -->
            <div class="column">
                <p>At its core, a web server is just a loop.</p>

                <ul>
                    <li>Wait for a client to connect</li>
                    <li>Accept the connection</li>
                    <li>Handle the request</li>
                    <li>Close the connection</li>
                    <li>Repeat forever</li>
                </ul>

                <p>
                    This pattern exists in <strong>every web server</strong>,  
                    no matter how advanced the framework.
                </p>

                <p>
                    Right now, we’ll focus on <em>what happens during one request</em>.
                </p>
            </div>

            <!-- Right column: code -->
            <div class="column">
                <pre><code class="language-python">import socket

server_socket = socket.socket(
    socket.AF_INET,
    socket.SOCK_STREAM,
)
server_socket.bind(("127.0.0.1", 8002))
server_socket.listen(5)

while True:
    client_socket, addr = server_socket.accept()
    handle_client(client_socket)</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 8: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>What a Browser Actually Sends</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: explanation -->
            <div class="column">
                <p>When a browser connects, it sends plain text.</p>

                <ul>
                    <li>An HTTP request is just lines of text</li>
                    <li>The first line tells us what the client wants</li>
                    <li>Everything else is metadata (headers)</li>
                </ul>

                <p>
                    If we can:
                </p>

                <ul>
                    <li>Read bytes from the socket</li>
                    <li>Decode them into text</li>
                    <li>Understand the first line</li>
                </ul>

                <p>
                    Then we can build a real web server.
                </p>
            </div>

            <!-- Right column: raw HTTP -->
            <div class="column">
                <pre><code class="language-text">GET /index.html HTTP/1.1
Host: 127.0.0.1:8002
User-Agent: Firefox
Accept: text/html
Connection: keep-alive</code></pre>
            </div>
        </div>
    </div>
</div>



<!-- SLIDE 9: WHAT HANDLE_CLIENT REALLY DOES -->
<div class="slide">
    <div class="slide-header">
        <h2>What Happens Inside <code>handle_client()</code></h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: conceptual steps -->
            <div class="column">
                <p>This function is where HTTP actually happens.</p>

                <p>Every request follows the same basic sequence:</p>

                <ol>
                    <li><strong>Read bytes</strong> from the socket</li>
                    <li><strong>Decode</strong> bytes into text</li>
                    <li><strong>Parse</strong> the requested path</li>
                    <li><strong>Load</strong> a file from disk</li>
                    <li><strong>Wrap</strong> it in HTTP headers</li>
                    <li><strong>Send</strong> it back to the client</li>
                </ol>

                <p>
                    Each step is simple.  
                    Together, they <strong>are a web server</strong>.
                </p>

                <p>
                    Frameworks like Flask hide this, but they do
                    <em>exactly the same work</em>.
                </p>
            </div>

            <!-- Right column: annotated code -->
            <div class="column">
                <pre><code class="language-python">def handle_client(client_socket):
    # 1. Read the request
    request_bytes = client_socket.recv(1024)
    request = request_bytes.decode("utf-8")

    # 2. Parse what they want
    path = parse_http_path(request)

    # 3. Find the file
    file_path = STATIC_DIR / path.lstrip("/")

    # 4. Read it from disk
    body = file_path.read_bytes()

    # 5. Build HTTP response
    response = http_response(
        body,
        content_type="text/html"
    )

    # 6. Send it back
    client_socket.sendall(response)
    client_socket.close()</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 10: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>A Real (Blocking) Web Server</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: summary -->
            <div class="column">
                <p>We now have a real, working HTTP server.</p>

                <ul>
                    <li>Serves files from a <strong>static directory</strong></li>
                    <li>Uses <code>pathlib</code> for safe path handling</li>
                    <li>Correct <strong>Content-Type</strong> headers via MIME mapping</li>
                    <li>Supports HTML, CSS, JS, images, SVGs</li>
                    <li>Clean shutdown with <code>Ctrl+C</code></li>
                </ul>

                <p>
                    You can open a browser, load pages, navigate links,
                    and everything works.
                </p>

                <p>
                    This is a <strong>proper HTTP server</strong> —
                    just without frameworks.
                </p>

                <p><strong>But:</strong> it still handles one request at a time.</p>
            </div>

            <!-- Right column: code snapshot -->
            <div class="column">
                <pre><code class="language-python">def handle_client(client_socket):
    request = client_socket.recv(1024)
    path = parse_http_path(request.decode())

    file_path = resolve_request_path(path)

    if file_path.exists():
        body = file_path.read_bytes()
        content_type = get_content_type(file_path)
        response = http_response(body, content_type)
    else:
        response = http_response(
            b"&lt;h1&gt;404 Not Found&lt;/h1&gt;",
            status="404 Not Found",
        )

    client_socket.sendall(response)
    client_socket.close()</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 11: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>Where the Server Blocks</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: problem framing -->
            <div class="column">
                <p>When many clients connect at once, this server slows to a crawl.</p>

                <p>The reason is not HTTP, files, or Python.</p>

                <p><strong>The problem is waiting.</strong></p>

                <ul>
                    <li>Each client is handled fully before the next begins</li>
                    <li>While one request is being processed, others wait</li>
                    <li>Under load, connections queue up and time out</li>
                </ul>

                <p>
                    This is what “blocking” really means.
                </p>
            </div>

            <!-- Right column: highlighted blocking loop -->
            <div class="column">
                <pre><code class="language-python">while True:
    client_socket, addr = server_socket.accept()

    # ⛔ Server is now busy
    handle_client(client_socket)
    # ⛔ Everyone else waits here</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 12: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>Step 1: Async Streams</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: explanation -->
            <div class="column">
                <p>We replaced blocking sockets with <strong>asyncio streams</strong>:</p>

                <ul>
                    <li><code>asyncio.start_server()</code> gives us <code>reader</code> & <code>writer</code></li>
                    <li><code>await reader.read(1024)</code> pauses only this task while waiting for I/O</li>
                    <li>Other requests can be handled immediately</li>
                    <li>We no longer block the entire server on a single request</li>
                </ul>

                <p>
                    The goal: keep the server responsive under load.
                </p>
            </div>

            <!-- Right column: code highlight -->
            <div class="column">
                <pre><code class="language-python">async def handle_client(reader, writer):
    # Async read — only this client waits
    request_bytes = await reader.read(1024)

    if not request_bytes:
        writer.close()
        return

    # Decode and parse path as before
    request = request_bytes.decode("utf-8", errors="ignore")
    path = parse_http_path(request)</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 13: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>Step 2: Writing Responses Asynchronously</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: explanation -->
            <div class="column">
                <p>Sending data is now also non-blocking:</p>

                <ul>
                    <li><code>writer.write()</code> queues bytes to be sent</li>
                    <li><code>await writer.drain()</code> pauses only this task until the buffer clears</li>
                    <li>Other tasks can run immediately — no waiting for slow clients</li>
                    <li>We still reuse the same HTTP response logic as before</li>
                </ul>

                <p>This lets multiple clients get responses concurrently.</p>
            </div>

            <!-- Right column: code highlight -->
            <div class="column">
                <pre><code class="language-python"># Build the response as before
response = http_response(body, content_type=content_type)

# Async write — only this client is paused
writer.write(response)
await writer.drain()

# Close the connection
writer.close()</code></pre>
            </div>
        </div>
    </div>
</div>


<!-- SLIDE 14: TWO COLUMNS -->
<div class="slide">
    <div class="slide-header">
        <h2>Step 3: Event Loop</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left column: explanation -->
            <div class="column">
                <p>The infinite blocking loop is replaced with <strong>asyncio's event loop</strong>:</p>

                <ul>
                    <li><code>asyncio.start_server(handle_client, ...)</code> schedules each connection as a task</li>
                    <li><code>async with server:</code> manages the server lifecycle cleanly</li>
                    <li><code>await server.serve_forever()</code> runs the loop until cancelled</li>
                    <li>Clean shutdown with <code>Ctrl+C</code> is now supported</li>
                </ul>

                <p>
                    The magic: multiple clients handled concurrently with the same Python process.
                </p>
            </div>

            <!-- Right column: code highlight -->
            <div class="column">
                <pre><code class="language-python">async def main():
    server = await asyncio.start_server(
        handle_client,
        host="127.0.0.1",
        port=8002,
    )

    async with server:
        try:
            await server.serve_forever()
        except asyncio.CancelledError:
            print("Shutting down gracefully...")

if __name__ == "__main__":
    asyncio.run(main())</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 1: Form Submission Fails</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <!-- Left: explanation -->
            <div class="column">
                <p>Our first form on <code>complex.html</code> gave a 404:</p>
                <ul>
                    <li>We only had GET routes for "/" and "/about"</li>
                    <li>POST requests to "/submit" were unknown</li>
                    <li>Static fallback was not fully integrated yet</li>
                </ul>
                <p>Result: form submission “broke” the server.</p>
            </div>

            <!-- Right: simple visual -->
            <div class="column">
                <pre><code class="language-text">POST /submit HTTP/1.1
Host: localhost

name=Alice&message=Hello
-->
404 Not Found!</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 2: Initial Fix Attempts</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <p>We tried adding a route handler for <code>/submit</code>:</p>
                <ul>
                    <li>Now POST /submit works</li>
                    <li>But static files under <code>/static</code> start failing</li>
                    <li>Reason: route matching now overrides static fallback</li>
                </ul>
                <p>Lesson: routing and static files need to coexist.</p>
            </div>

            <div class="column">
                <pre><code class="language-python">@route("POST", "/submit")
def handle_form_submission(request):
    # process request
    return b"&lt;h1&gt;Form submitted!&lt;/h1&gt;"</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 3: Static Fallback Recovery</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <p>Solution: if no route matches, try serving a static file:</p>
                <ul>
                    <li>Routes now take precedence</li>
                    <li>Static files remain accessible</li>
                    <li>404 only happens if neither matches</li>
                </ul>
            </div>

            <div class="column">
                <pre><code class="language-python">handler = routes.get((method, path))
if handler:
    response = handler(request)
else:
    # fallback to static
    response = load_static_file(path) or 404_page()</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 4: Accepting Request Data</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <p>Now handlers receive the <code>Request</code> object:</p>
                <ul>
                    <li>GET or POST method</li>
                    <li>Path, headers, and body</li>
                    <li>Form data can be parsed inside the handler</li>
                </ul>
                <p>This allows dynamic responses based on input.</p>
            </div>

            <div class="column">
                <pre><code class="language-python">@route("POST", "/submit")
def handle_form_submission(request):
    data = parse_qs(request.body.decode("utf-8"))
    name = data.get("name", ["Anonymous"])[0]
    return f"&lt;h1&gt;Hello, {name}&lt;/h1&gt;".encode("utf-8")</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 5: Full Functional Flow</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <ul>
                    <li>Route matches → call handler</li>
                    <li>No route → static file fallback</li>
                    <li>Neither → 404</li>
                    <li>POST data handled properly → can display user input</li>
                    <li>GET requests for static files still work</li>
                </ul>
                <p>Result: everything works as expected.</p>
            </div>

            <div class="column">
                <pre><code class="language-python"># Inside handle_client
handler = routes.get((request.method, request.path))
if handler:
    response = handler(request)
else:
    body = load_static_file(request.path)
    response = http_response(body) if body else http_response(404_page())</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Step 6: Server Complete</h2>
    </div>

    <div class="slide-body">
        <div class="layout-2">
            <div class="column">
                <ul>
                    <li>GET / → index.html</li>
                    <li>GET /about → about.html</li>
                    <li>GET /static/... → static files served</li>
                    <li>POST /submit → form submission handled dynamically</li>
                    <li>404 for everything else</li>
                </ul>
                <p>All routes, static files, and POST forms now coexist seamlessly.</p>
            </div>

            <div class="column">
                <pre><code class="language-text">POST /submit
name=Alice&message=Hello

→ Server responds with:
&lt;h2&gt;Thank you, Alice!&lt;/h2&gt;
&lt;p&gt;Your message: Hello&lt;/p&gt;</code></pre>
            </div>
        </div>
    </div>
</div>


<div class="slide">
    <div class="slide-header">
        <h2>Wrapping Up</h2>
    </div>

    <div class="slide-body">
        <div class="layout-1" style="text-align: left;">
            <p>• Explored building a minimal <strong>async Python HTTP server</strong> from scratch</p>
            <p>• Handled <strong>static files</strong> and proper <strong>HTTP responses</strong></p>
            <p>• Added <strong>routing</strong> and <strong>decorators</strong> for clean endpoints</p>
            <p>• Implemented <strong>dynamic POST handling</strong> for forms</p>
            <p>• Ensured <strong>static fallback</strong> works alongside dynamic routes</p>
            <p>• Maintained a clean, modular structure for future expansion</p>

            <p style="margin-top: 2rem;">✅ Everything works together: GET, POST, static files, routes, and 404s.</p>

            <p style="margin-top: 2rem; font-style: italic;">Thank you for your attention!</p>
            <p>Any questions?</p>
        </div>
    </div>
</div>


<div class="slide-number">
    <span id="current-slide">1</span> / <span id="total-slides">3</span>
</div>

<div class="navigation">
    <button onclick="changeSlide(-1)">← Previous</button>
    <button onclick="changeSlide(1)">Next →</button>
</div>

<script>
let currentSlide = 0;
const slides = document.querySelectorAll(".slide");

document.getElementById("total-slides").textContent = slides.length;

function showSlide(n) {
    slides[currentSlide].classList.remove("active");
    currentSlide = Math.max(0, Math.min(n, slides.length - 1));
    slides[currentSlide].classList.add("active");
    document.getElementById("current-slide").textContent = currentSlide + 1;
}

function changeSlide(delta) {
    showSlide(currentSlide + delta);
}

document.addEventListener("keydown", e => {
    if (e.key === "ArrowRight" || e.key === " ") changeSlide(1);
    if (e.key === "ArrowLeft") changeSlide(-1);
});
</script>

</body>
</html>
